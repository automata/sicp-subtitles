1
00:00:14,325 --> 00:00:17,723
I'd like to welcome you to
this course on computer science.

2
00:00:27,967 --> 00:00:29,782
Actually, it's a terrible way to start.

3
00:00:30,088 --> 00:00:31,922
Computer science
is a terrible name for this business.

4
00:00:32,288 --> 00:00:35,023
First of all it's not a science.

5
00:00:36,308 --> 00:00:39,341
It might be engineering...
or it might be art...

6
00:00:39,803 --> 00:00:41,597
Or we'll actually see that computer...

7
00:00:41,921 --> 00:00:44,700
so-called 'science'
actually has a lot in common with magic.

8
00:00:44,996 --> 00:00:46,287
We will see that in this course.

9
00:00:47,231 --> 00:00:52,370
So it's not a science. It's also
not really very much about computers.

10
00:00:53,589 --> 00:00:55,986
And it's not about computers
in the same sense that...

11
00:00:56,543 --> 00:01:00,016
that physics is not really
about particle accelerators...

12
00:01:00,372 --> 00:01:05,465
and biology is not really
about microscopes and Petri dishes.

13
00:01:05,993 --> 00:01:11,208
and it's not about computers
in the same sense that geometry

14
00:01:11,631 --> 00:01:15,210
is not really about
using surveying instruments.

15
00:01:16,225 --> 00:01:20,680
In fact there is a lot of commonality
between computer science and geometry.

16
00:01:21,081 --> 00:01:25,063
Geometry first of all
is another subject with a lousy name.

17
00:01:25,794 --> 00:01:29,206
The name comes from 'Gaia' meaning
the earth and 'Metron' meaning to measure.

18
00:01:29,722 --> 00:01:33,237
Geometry originally meant
measuring the earth... or surveying.

19
00:01:34,231 --> 00:01:36,915
And the reason for that was
that thousands of years ago

20
00:01:37,518 --> 00:01:41,684
the Egyptian priesthood
developed rudiments of geometry

21
00:01:42,348 --> 00:01:44,706
in order to figure out how to restore the

22
00:01:45,228 --> 00:01:48,367
boundaries of fields that were destroyed
in the annual flooding of the Nile.

23
00:01:49,014 --> 00:01:51,764
And to the Egyptians who did that
the geometry really was

24
00:01:52,186 --> 00:01:53,880
the use of surveying instruments.

25
00:01:55,529 --> 00:01:58,322
Now, the reason that we think that
computer science is about computers

26
00:01:58,669 --> 00:02:00,424
is pretty much the same reason

27
00:02:00,983 --> 00:02:03,743
that the Egyptians thought geometry
was about surveying instruments.

28
00:02:04,399 --> 00:02:05,623
and that is when

29
00:02:06,009 --> 00:02:09,715
some field is just getting started and
you don't really understand it very well

30
00:02:11,023 --> 00:02:14,079
it's very easy to confuse
the essence of what you're doing

31
00:02:14,660 --> 00:02:16,068
with the tools that you use.

32
00:02:17,216 --> 00:02:21,796
And indeed on some absolute
scale of things we probably know less

33
00:02:22,269 --> 00:02:24,486
about the essence of computer science

34
00:02:24,943 --> 00:02:27,376
than the ancient Egyptians
really knew about geometry.

35
00:02:29,675 --> 00:02:32,248
Well, what I mean
by the essence of computer science,

36
00:02:32,549 --> 00:02:33,549
what I mean by the essence of geometry...

37
00:02:34,066 --> 00:02:37,367
See, it's certainly true that these
Egyptians often used surveying instruments.

38
00:02:37,761 --> 00:02:39,390
But when we look back on them

39
00:02:40,072 --> 00:02:42,820
after a couple of thousands years we say
"Gee! What they were doing?"

40
00:02:43,556 --> 00:02:47,475
The important stuff they were doing
was to begin to formalize

41
00:02:48,141 --> 00:02:50,993
notions about space and time.

42
00:02:51,328 --> 00:02:55,031
To start a way of talking about...

43
00:02:55,574 --> 00:03:00,062
mathematical truth formally that led
to the axiomatic method, that led to...

44
00:03:00,646 --> 00:03:02,505
sort of all of modern mathematics.

45
00:03:04,055 --> 00:03:08,735
Figuring out a way to talk precisely
about so-called 'declarative' knowledge -

46
00:03:09,164 --> 00:03:11,191
'what is true'.

47
00:03:12,514 --> 00:03:15,842
Well, similarly, I think in the future
people will look back and say,

48
00:03:16,243 --> 00:03:18,235
yes, those
primitives in the twentieth century

49
00:03:18,537 --> 00:03:20,979
were fiddling around
with these gadgets called computers,

50
00:03:21,527 --> 00:03:23,332
but really what they were doing

51
00:03:23,746 --> 00:03:27,333
is starting to learn how to formalize...

52
00:03:28,815 --> 00:03:32,026
formalize intuitions about... process...

53
00:03:32,461 --> 00:03:34,069
how to do things.

54
00:03:39,360 --> 00:03:48,073
Starting to develop a way...
to talk precisely

55
00:03:48,555 --> 00:03:51,305
about 'how to' knowledge,

56
00:03:51,741 --> 00:03:56,100
as opposed to geometry
that talks about 'what is true'.

57
00:03:56,569 --> 00:03:58,498
Let me give you an example of that.

58
00:04:01,893 --> 00:04:06,554
Let's take a look... Here is
a piece of... a piece of mathematics.

59
00:04:06,972 --> 00:04:09,506
Right? That says what a square root is.

60
00:04:10,133 --> 00:04:14,359
The square root of X is the number Y

61
00:04:14,768 --> 00:04:17,972
such that Y squared is equal to X

62
00:04:18,373 --> 00:04:20,091
and Y is greater than zero.

63
00:04:20,469 --> 00:04:22,040
Now that's a fine piece of mathematics,

64
00:04:22,667 --> 00:04:27,369
but just telling you what a square root
is doesn't really say anything about...

65
00:04:28,086 --> 00:04:30,508
about
how you might go out and find one.

66
00:04:31,093 --> 00:04:35,758
Let's contrast that
with a piece of imperative knowledge.

67
00:04:37,002 --> 00:04:39,559
Right? How you might
go out and find the square root.

68
00:04:39,901 --> 00:04:45,300
This in fact also comes from Egypt.
Not ancient-ancient Egypt.

69
00:04:45,701 --> 00:04:48,563
This is an algorithm
due to Heron of Alexandria

70
00:04:50,067 --> 00:04:52,526
called how to find a square root
by successive averaging.

71
00:04:52,927 --> 00:04:54,248
And what it says is...

72
00:04:54,661 --> 00:04:57,669
That in order to find a square root...

73
00:05:01,740 --> 00:05:04,970
... in order to find a square root
you make a guess,

74
00:05:05,983 --> 00:05:08,112
you improve that guess,

75
00:05:09,495 --> 00:05:13,563
and the way you improve the guess is to
average the guess and X over the guess

76
00:05:14,056 --> 00:05:16,864
(we'll talk a little bit later
why that's a reasonable thing)

77
00:05:17,196 --> 00:05:19,210
and you keep improving
the guess until it's good enough.

78
00:05:19,767 --> 00:05:23,168
That's a method.
That's how to do something.

79
00:05:23,694 --> 00:05:27,485
As opposed to declarative knowledge
that says what you're looking for.

80
00:05:28,080 --> 00:05:30,942
And that's a process.

81
00:05:34,275 --> 00:05:38,350
Well, what's a process in general?

82
00:05:38,784 --> 00:05:43,844
It's a kind of hard to say. You can
think of it as like a magical spirit

83
00:05:44,625 --> 00:05:47,432
that sort of lives in the computer and
does something.

84
00:05:47,849 --> 00:05:49,381
And...

85
00:05:52,169 --> 00:05:58,065
The thing that directs a process is a
pattern of rules called a procedure.

86
00:06:01,715 --> 00:06:04,544
So procedures are the spells if you like

87
00:06:04,940 --> 00:06:09,349
that control these magical spirits
that are the processes.

88
00:06:09,749 --> 00:06:12,331
And... well I guess you know
everyone needs a magical language

89
00:06:12,732 --> 00:06:15,712
and sorcerers, right,
real sorcerers use ancient Arcadian,

90
00:06:16,311 --> 00:06:17,513
or Sumerian, or Babylonian or whatever.

91
00:06:18,844 --> 00:06:23,275
We're gonna control our spirits
in a magical language called LISP,

92
00:06:24,394 --> 00:06:28,043
which is a language
designed for talking about...

93
00:06:28,508 --> 00:06:31,703
for casting the spells that
are procedures to direct the processes.

94
00:06:32,232 --> 00:06:33,440
Now, it's very easy to learn LISP.

95
00:06:33,775 --> 00:06:36,837
In fact, in a few minutes I'm gonna
teach you essentially all of LISP.

96
00:06:37,196 --> 00:06:39,491
I'll teach you
essentially all of the rules...

97
00:06:40,425 --> 00:06:43,016
And you shouldn't find
that particularly surprising.

98
00:06:43,451 --> 00:06:46,522
That's sort of like saying it's very easy
to learn the rules of chess

99
00:06:46,923 --> 00:06:49,721
and indeed in a few minutes
you can tell somebody the rules of chess

100
00:06:50,558 --> 00:06:52,736
but of course
that's very different from saying

101
00:06:53,283 --> 00:06:55,146
you understand
the implications of those rules

102
00:06:55,381 --> 00:06:58,038
and how to use those rules
to become a masterful chess player.

103
00:06:58,452 --> 00:06:59,880
Well, LISP is the same way.

104
00:07:00,236 --> 00:07:03,118
We're gonna state the rules in a few
minutes and it will be very easy to see,

105
00:07:03,519 --> 00:07:06,899
but what's really hard is gonna be
the implications of those rules.

106
00:07:07,402 --> 00:07:10,699
How you exploit those rules
to be a master programmer.

107
00:07:12,032 --> 00:07:15,452
And the implications of those rules
are gonna take us the...

108
00:07:16,053 --> 00:07:19,137
well, the whole rest of this subject
and of course way beyond.

109
00:07:21,457 --> 00:07:23,553
OK. So, in computer science

110
00:07:24,462 --> 00:07:30,347
we're in the business of formalizing the
sort of 'how to' imperative knowledge.

111
00:07:30,768 --> 00:07:32,430
Right? How to do stuff.

112
00:07:33,155 --> 00:07:35,653
And real issues
of computer science are of course not,

113
00:07:35,987 --> 00:07:38,092
you know,
telling people how to do square roots.

114
00:07:38,734 --> 00:07:41,242
'Cause if that was all it was
it wouldn't be no big deal.

115
00:07:41,609 --> 00:07:46,100
The real problems come when
we try to build very-very large systems.

116
00:07:46,572 --> 00:07:49,279
Right? Computer programs
that are thousands of pages long.

117
00:07:49,610 --> 00:07:53,302
So long that nobody can really
hold them in their heads all at once.

118
00:07:53,719 --> 00:08:00,191
And the only reason that that's possible
is because there are techniques...

119
00:08:01,388 --> 00:08:04,219
There are techniques...

120
00:08:06,113 --> 00:08:14,423
for controlling the complexity...

121
00:08:17,565 --> 00:08:19,613
of these large systems.

122
00:08:20,148 --> 00:08:21,353
And these techniques for

123
00:08:21,697 --> 00:08:24,261
controlling complexity
are what this course is really about.

124
00:08:24,656 --> 00:08:28,062
And in some sense that's really
what computer science is about.

125
00:08:29,540 --> 00:08:31,459
Now that may seem
like a very strange thing to say,

126
00:08:31,794 --> 00:08:33,628
because after all a lot of people

127
00:08:34,132 --> 00:08:37,643
beside computer scientists
deal with controlling complexity.

128
00:08:38,033 --> 00:08:41,010
A large airliner
is an extremely complex system.

129
00:08:41,694 --> 00:08:43,714
And the aeronautical engineers
who design that air,

130
00:08:44,131 --> 00:08:46,005
you know,
are dealing with the men's complexity.

131
00:08:46,937 --> 00:08:48,134
But there's a difference

132
00:08:48,564 --> 00:08:52,986
between that kind of complexity and
what we deal with in computer science.

133
00:08:54,900 --> 00:09:00,112
And that is that computer science
in some sense isn't real.

134
00:09:02,550 --> 00:09:06,548
You see, when an engineer
is designing a physical system

135
00:09:06,969 --> 00:09:10,980
that's made out of real parts, right,
the engineers who worry about that

136
00:09:11,663 --> 00:09:16,223
have to address problems of tolerance and
approximation and noise in the system.

137
00:09:16,624 --> 00:09:19,913
So, for example, as an electrical
engineer I can go off and easily build

138
00:09:20,239 --> 00:09:22,849
a one-stage amplifier
or a two-stage amplifier.

139
00:09:23,283 --> 00:09:26,552
And I can imagine cascading a lot of
them to build a million-stage amplifier,

140
00:09:26,974 --> 00:09:29,412
But it's ridiculous to build
such a thing, because

141
00:09:29,747 --> 00:09:33,212
long before the millionth stage the
thermal noise in those components

142
00:09:33,613 --> 00:09:35,152
way at the beginning is gonna get amplified

143
00:09:35,459 --> 00:09:37,375
and make the whole thing meaningless.

144
00:09:38,827 --> 00:09:42,950
Computer science
deals with idealized components.

145
00:09:43,867 --> 00:09:45,808
We know as much as we want

146
00:09:46,204 --> 00:09:49,369
about these little programming data pieces
that we're fitting things together.

147
00:09:50,356 --> 00:09:54,099
So there's... We don't have to worry
about tolerance and that means

148
00:09:55,255 --> 00:09:59,845
that in building a large program
there is not all that much difference

149
00:10:00,343 --> 00:10:04,586
between what I can build
and what I can imagine.

150
00:10:05,367 --> 00:10:09,741
Because the parts of these abstract
entities that I know as much as I want.

151
00:10:10,142 --> 00:10:12,553
I know about them
as precisely as I'd like.

152
00:10:13,227 --> 00:10:15,269
So as opposed
to other kinds of engineering

153
00:10:15,667 --> 00:10:17,453
where the constraints on what
you can build are the constraints

154
00:10:17,839 --> 00:10:20,882
of physical systems, the constraints
of physics and noise and approximation.

155
00:10:21,277 --> 00:10:23,324
The constraints imposed...

156
00:10:24,012 --> 00:10:28,107
in building large software systems
are the limitations of our own minds.

157
00:10:28,834 --> 00:10:33,462
So in that sense computer science
is like an abstract form of engineering.

158
00:10:33,796 --> 00:10:36,146
It's the kind of engineering
where you ignore the constraints

159
00:10:36,642 --> 00:10:38,594
that are imposed by reality.

160
00:10:41,593 --> 00:10:45,766
OK. Well, what are...
some of these techniques?

161
00:10:46,343 --> 00:10:49,097
They are not special to computer science.

162
00:10:50,216 --> 00:10:55,508
First technique which is used in all of
engineering is kind of abstraction

163
00:10:56,474 --> 00:11:00,779
called black-box abstraction.

164
00:11:06,863 --> 00:11:12,934
Take something and build a box about it.

165
00:11:14,087 --> 00:11:20,634
Let's see for example
if we looked at that square root method

166
00:11:22,503 --> 00:11:26,091
I might want to take that and...

167
00:11:27,136 --> 00:11:30,256
build a box that sort of says

168
00:11:30,656 --> 00:11:37,771
'to find a square root of x'

169
00:11:38,506 --> 00:11:41,651
Now it might be
a whole complicated set of rules

170
00:11:42,353 --> 00:11:48,017
and that might end up being a kind of
thing where I can put in say 36 and say

171
00:11:48,518 --> 00:11:52,332
what's the square root of 36
and out comes 6.

172
00:11:53,877 --> 00:11:57,577
And the important thing is that I'd like
to design that

173
00:11:58,309 --> 00:12:05,829
so that if George comes along and would
like to compute, say, the square root

174
00:12:06,348 --> 00:12:13,992
of A plus the square root of B he can
take this thing and use it as a module

175
00:12:14,355 --> 00:12:17,259
without having to look inside and build
something that looks like this

176
00:12:18,252 --> 00:12:26,350
like an A and B, and a square root box,
and another square root box,

177
00:12:29,610 --> 00:12:31,760
and then something that adds.

178
00:12:32,293 --> 00:12:36,190
Now it would put out the answer.
And you can see, just from the fact that

179
00:12:36,591 --> 00:12:41,499
I wanna do that is from George's point
of view the internals of what's in here

180
00:12:41,900 --> 00:12:45,508
should not be important.
So, for instance, it shouldn't matter

181
00:12:45,841 --> 00:12:50,175
that when I wrote this I said
I wanna find the square root of X.

182
00:12:50,523 --> 00:12:53,835
I could have said the square root of Y.
Or the square root of A.

183
00:12:54,190 --> 00:12:58,068
Or anything at all.
And that's the fundamental notion

184
00:12:58,566 --> 00:13:02,085
of putting something in a box...

185
00:13:03,435 --> 00:13:06,751
using black-box abstraction
to suppress detail.

186
00:13:07,370 --> 00:13:11,130
And the reason for that is that you
wanna go of and build bigger boxes.

187
00:13:11,960 --> 00:13:14,215
Now, there's another reason for doing
black-box abstraction.

188
00:13:14,529 --> 00:13:18,047
Other than you wanna suppress detail
for building bigger boxes.

189
00:13:18,448 --> 00:13:26,131
Sometimes you wanna say that your way of
doing something, your 'how to' method

190
00:13:27,907 --> 00:13:30,513
is an instance of a more general thing.

191
00:13:30,946 --> 00:13:34,732
And you'd like your language to be able
to express that generality.

192
00:13:35,248 --> 00:13:39,462
Let me show you another example sticking
with square root. Let's go back

193
00:13:39,863 --> 00:13:43,978
and take another look at that slide
with the square root algorithm on it.

194
00:13:44,436 --> 00:13:50,042
Remember what that says? That says in
order to do something I'll make a guess,

195
00:13:50,590 --> 00:13:54,989
and I'll improve that guess, and I
sort of keep improving that guess.

196
00:13:55,788 --> 00:14:00,416
So, there's a general strategy
of looking for something.

197
00:14:01,189 --> 00:14:03,770
And the way I find it
is that I keep improving it.

198
00:14:04,171 --> 00:14:10,379
Now that's a particular case of another
kind of strategy

199
00:14:10,984 --> 00:14:12,896
for finding a fixed point of something.

200
00:14:14,466 --> 00:14:22,192
To have fixed point of a function...
A fixed point... of a function...

201
00:14:23,417 --> 00:14:28,138
is something... is a value...
Fixed point of a function F is a value Y

202
00:14:28,539 --> 00:14:32,030
such that F of Y equals Y.

203
00:14:32,986 --> 00:14:35,680
And the way I might do that...

204
00:14:38,690 --> 00:14:44,076
is start with a guess, and if I want
something that doesn't change

205
00:14:44,477 --> 00:14:47,103
when I keep applying F
is I keep applying F over and over

206
00:14:47,603 --> 00:14:51,730
until that result doesn't change very
much. So there is a general strategy

207
00:14:52,238 --> 00:14:55,858
and then for example
to compute the square root of X

208
00:14:56,263 --> 00:14:57,822
I can try and find a fixed point

209
00:14:58,765 --> 00:15:03,041
of the function which takes
Y to the average of X over Y.

210
00:15:03,388 --> 00:15:07,568
And the idea of that is that if I really
had Y equal to the square root of X

211
00:15:08,116 --> 00:15:11,619
then Y and X over Y
would be the same value.

212
00:15:12,077 --> 00:15:13,532
They'd both be the square root of X.

213
00:15:13,997 --> 00:15:18,732
Right? Cause X over the square root of X
is the square root of X.

214
00:15:19,106 --> 00:15:21,805
And so the average, if Y were equal to
the square root of X

215
00:15:22,283 --> 00:15:25,612
then the average wouldn't change.

216
00:15:26,019 --> 00:15:29,001
So the square root of X is a fixed point
of that particular function.

217
00:15:30,079 --> 00:15:34,778
Now, what I'd like to have...
I'd like to express the general strategy

218
00:15:35,179 --> 00:15:40,497
for finding fixed points. So what
I might imagine doing is to find...

219
00:15:40,970 --> 00:15:47,816
is to be able to use my language
to define a box that says fixed point.

220
00:15:49,468 --> 00:15:52,612
Just like I could make a box that says
square root and I'd like to be able

221
00:15:53,012 --> 00:15:55,617
to express this in my language.

222
00:15:56,142 --> 00:16:00,980
So I'd like to express not only the
imperative how to knowledge

223
00:16:01,381 --> 00:16:04,212
about particular thing like square root,
but I'd like to be able to express

224
00:16:04,613 --> 00:16:08,704
the imperative knowledge of how to do a
general thing like how to find fixed point.

225
00:16:09,821 --> 00:16:13,493
And in fact let's go back
and look at that slide again.

226
00:16:14,896 --> 00:16:17,095
See, not only is...

227
00:16:21,467 --> 00:16:25,396
is this a piece of imperative
knowledge how to find a fixed point,

228
00:16:26,070 --> 00:16:29,215
but over here at the bottom there's another
piece of imperative knowledge,

229
00:16:29,706 --> 00:16:32,516
which says one way to compute square root

230
00:16:33,124 --> 00:16:35,833
is to apply
this general fixed point method.

231
00:16:36,191 --> 00:16:39,283
So I'd like to also be able to express
that imperative knowledge.

232
00:16:39,685 --> 00:16:45,157
What would that look like? That would
say this fixed point box is such that

233
00:16:45,650 --> 00:16:58,622
if I input to it the function that takes
Y to the average of Y and X over Y

234
00:16:59,491 --> 00:17:03,367
than what should come out of that
fixed point box is...

235
00:17:04,211 --> 00:17:07,420
a method for finding square roots.

236
00:17:08,642 --> 00:17:11,835
So in these boxes we're building we're
not only building boxes that

237
00:17:12,236 --> 00:17:15,405
you input numbers and output numbers.

238
00:17:16,338 --> 00:17:19,568
We're gonna be building in boxes
that in effect compute methods

239
00:17:19,869 --> 00:17:21,266
like finding square root.

240
00:17:21,975 --> 00:17:25,943
And might take as their inputs functions

241
00:17:26,415 --> 00:17:29,299
like Y goes
to the average of Y and X over Y.

242
00:17:29,782 --> 00:17:32,608
Reason we wanna do that...
see, the reason...

243
00:17:33,009 --> 00:17:35,951
This is a procedure or end up being
a procedure as we'll see,

244
00:17:36,352 --> 00:17:41,006
whose value is another procedure. The
reason we wanna do that is because

245
00:17:41,307 --> 00:17:47,039
procedures are gonna be our ways of
talking about imperative knowledge.

246
00:17:47,952 --> 00:17:49,192
And the way to make that very powerful

247
00:17:49,577 --> 00:17:52,348
is to be able to talk
about other kinds of knowledge.

248
00:17:53,249 --> 00:17:56,545
So, here is a procedure that in fact
talks about another procedure.

249
00:17:56,946 --> 00:18:00,888
And the general strategy that itself
talks about general strategies.

250
00:18:03,504 --> 00:18:09,196
OK. Well, our first topic in this course
(there will be three major topics)

251
00:18:09,597 --> 00:18:13,749
will be black-box abstraction. Let's look
at that in a little bit more detail.

252
00:18:14,962 --> 00:18:20,629
Well, what we're gonna do is we will...

253
00:18:21,744 --> 00:18:26,857
We'll start out talking about how LISP
is built up out of primitive objects,

254
00:18:27,200 --> 00:18:29,227
what is the language supply with us.

255
00:18:29,647 --> 00:18:34,152
And we'll see that they are
primitive procedures and primitive data.

256
00:18:35,310 --> 00:18:38,214
Then we're gonna see
how do you take those primitives

257
00:18:38,515 --> 00:18:40,905
and combine them
to make more complicated things.

258
00:18:41,406 --> 00:18:42,886
Means of combination.

259
00:18:43,215 --> 00:18:46,169
And what we'll see is that they're
ways of putting things together,

260
00:18:46,470 --> 00:18:50,672
putting primitive procedures together
to make more complicated procedures.

261
00:18:50,867 --> 00:18:55,349
And we'll see how to put primitive data
together to make compound data.

262
00:18:55,758 --> 00:18:59,407
Then we'll say:
well, having made those compound things,

263
00:18:59,708 --> 00:19:02,189
how do you abstract them?

264
00:19:02,795 --> 00:19:04,912
How do you put
those black boxes around them

265
00:19:05,213 --> 00:19:07,711
so you can use them as
components in more complex things?

266
00:19:08,017 --> 00:19:11,225
And we'll see
that's done by defining procedures and

267
00:19:11,649 --> 00:19:15,152
a technique for dealing with
compound data called data abstraction.

268
00:19:15,522 --> 00:19:18,681
And then
what's maybe the most important thing is

269
00:19:19,016 --> 00:19:21,517
going from just the rules
to how does an expert work.

270
00:19:21,818 --> 00:19:26,298
How do you express common
patterns of doing things like saying

271
00:19:26,599 --> 00:19:28,463
well, there's a
general method of fixed point

272
00:19:28,764 --> 00:19:31,738
and square root
is a particular case of that.

273
00:19:32,023 --> 00:19:34,200
And we're gonna use

274
00:19:34,501 --> 00:19:37,627
I've already hinted that it's something
called higher order procedures, namely

275
00:19:37,928 --> 00:19:42,765
procedures, whose inputs
and outputs are themselves procedures.

276
00:19:43,200 --> 00:19:45,455
And we will also see
something very interesting we'll see

277
00:19:45,772 --> 00:19:48,272
as we go further and further on
and become more abstract

278
00:19:48,746 --> 00:19:49,763
there'll be very...

279
00:19:50,064 --> 00:19:53,096
well... the line between
what we consider to be data

280
00:19:53,447 --> 00:19:58,763
and what we consider to be procedures
is gonna blur at an incredible rate.

281
00:20:02,561 --> 00:20:05,843
Right, well, that's our first subject,

282
00:20:06,144 --> 00:20:08,675
black-box abstraction.
Let's look at the second topic.

283
00:20:10,840 --> 00:20:12,787
I can introduce it...

284
00:20:13,084 --> 00:20:18,731
Let's see that like this.
Suppose I want to express the idea.

285
00:20:19,441 --> 00:20:22,564
Remember, we're talking about ideas.

286
00:20:22,826 --> 00:20:25,773
Suppose, I wanna express the idea that

287
00:20:26,379 --> 00:20:28,981
I can take something

288
00:20:30,390 --> 00:20:34,897
and multiply it by
the sum of two other things.

289
00:20:35,830 --> 00:20:37,784
So for example I might say

290
00:20:38,185 --> 00:20:41,579
If I add 1 and 3
and multiply that by 2 I get 8.

291
00:20:41,880 --> 00:20:44,916
But I'm talking about general idea
of what's called linear combination.

292
00:20:45,286 --> 00:20:48,801
That you can add two things
and multiply them by something else.

293
00:20:49,149 --> 00:20:51,919
It's very easy when I think
about it for numbers but suppose I...

294
00:20:52,280 --> 00:20:55,661
I also want to use
that same idea to think about

295
00:20:55,962 --> 00:20:58,712
I could add two vectors a1 and a2

296
00:20:59,535 --> 00:21:02,758
and then scale them
by some factor x and get another vector.

297
00:21:03,059 --> 00:21:09,736
Or I might say I wanna think
about a1 and a2 as being polynomials.

298
00:21:10,525 --> 00:21:12,906
And I might wanna
add those two polynomials

299
00:21:13,207 --> 00:21:17,104
and then multiply them by two
to get a more complicated one.

300
00:21:20,116 --> 00:21:24,079
Or a1 and a2 might be electrical signals

301
00:21:24,455 --> 00:21:27,086
and I might wanna think about
summing those two electrical signals

302
00:21:27,428 --> 00:21:30,767
and then putting the whole thing
to an amplifier and multiplying it by

303
00:21:31,168 --> 00:21:33,252
some factor of two or something.

304
00:21:33,693 --> 00:21:37,463
The idea is I wanna think
about the general notion of that.

305
00:21:38,358 --> 00:21:40,104
Now, if our language

306
00:21:40,505 --> 00:21:45,916
is gonna be a good language for
expressing those kinds of general ideas.

307
00:21:46,902 --> 00:21:50,061
It's if I really can do that.

308
00:21:50,521 --> 00:21:52,659
So I'd like to be able to say

309
00:21:54,599 --> 00:22:01,893
I gonna multiply by x the sum of a1 and a2

310
00:22:02,391 --> 00:22:05,647
and I'd like that
to express the general idea

311
00:22:06,032 --> 00:22:08,972
of all different kinds of things
that a1 and a2 could be.

312
00:22:09,916 --> 00:22:13,949
Now, if you think about that, there's
a problem because after all the actual

313
00:22:14,919 --> 00:22:18,120
primitive operations that go on in the
machine are obviously gonna be different

314
00:22:18,521 --> 00:22:22,599
if I'm adding two numbers
then if I'm adding two polynomials.

315
00:22:22,900 --> 00:22:27,434
Or if I'm adding the representation
of two electrical signals or waveforms.

316
00:22:27,842 --> 00:22:30,077
Somewhere there has to be the knowledge

317
00:22:30,434 --> 00:22:35,757
of the kinds of various things that
you can add and the ways of adding them.

318
00:22:37,045 --> 00:22:38,544
Now, to construct such a system,

319
00:22:38,845 --> 00:22:40,653
the question is
where do I put that knowledge?

320
00:22:41,054 --> 00:22:45,833
How do I think about the different
kinds of choices I have? And if tomorrow

321
00:22:46,252 --> 00:22:50,263
George comes up with a new kind of object
that might be added and multiplied,

322
00:22:50,817 --> 00:22:54,483
how do I add George's new object to this
system without screwing up everything

323
00:22:54,783 --> 00:22:56,596
that was already there?

324
00:22:57,635 --> 00:23:00,245
That's gonna be the second big topic,

325
00:23:00,573 --> 00:23:04,687
the way of controlling that kind
of complexity. And the way you do that

326
00:23:05,062 --> 00:23:06,489
is by establishing

327
00:23:06,921 --> 00:23:09,155
conventional interfaces.

328
00:23:16,874 --> 00:23:18,642
Agreed upon ways

329
00:23:19,041 --> 00:23:22,035
of plugging things together,
just like in electrical engineering

330
00:23:22,534 --> 00:23:25,394
people have standard
impedances for connectors.

331
00:23:25,909 --> 00:23:28,193
And then you know if you build something
with one of the standard impedances, you

332
00:23:28,594 --> 00:23:32,154
can plug it together with something else.

333
00:23:32,778 --> 00:23:35,403
That's gonna be our second
large topic, conventional interfaces.

334
00:23:35,765 --> 00:23:36,860
What we're gonna see

335
00:23:37,624 --> 00:23:40,504
is first we're gonna talk about
the problem of generic operations,

336
00:23:40,805 --> 00:23:42,211
which is the one I alluded to.

337
00:23:42,527 --> 00:23:47,654
Things like plus that have to
work with all different kinds of data.

338
00:23:52,264 --> 00:23:54,361
So we'll talk about generic operations.

339
00:23:54,662 --> 00:23:57,447
Then we're gonna talk
about really large scale structures.

340
00:23:57,985 --> 00:24:01,240
How do you put together
very large programs that model

341
00:24:01,641 --> 00:24:04,655
the kinds of complex systems in the
real world that you'd like to model.

342
00:24:05,056 --> 00:24:10,046
And what we're gonna see is that
there are two very important metaphors

343
00:24:10,447 --> 00:24:11,497
for putting together such systems.

344
00:24:11,798 --> 00:24:16,200
One is called object oriented
programming where you sort of think of

345
00:24:16,814 --> 00:24:18,730
your system as a kind of society

346
00:24:19,031 --> 00:24:22,507
for little things that interact
by sending information between them.

347
00:24:23,201 --> 00:24:27,466
And then a second one is
operations on aggregates called streams

348
00:24:27,766 --> 00:24:29,137
where you think of a large system

349
00:24:29,438 --> 00:24:32,700
put together kind of
like a signal processing engineer

350
00:24:33,000 --> 00:24:35,857
puts together a large electrical system.

351
00:24:38,998 --> 00:24:40,721
That's gonna be our second topic.

352
00:24:43,065 --> 00:24:45,416
Now, the third thing we're gonna come to

353
00:24:45,817 --> 00:24:51,096
the third basic technique for controlling
complexity is making new languages.

354
00:24:51,494 --> 00:24:52,671
Cause sometimes,

355
00:24:53,028 --> 00:24:55,110
when you sort of overwhelmed
by the complexity of your design,

356
00:24:55,487 --> 00:24:59,991
the way that you control that complexity
is to pick a new design language.

357
00:25:01,164 --> 00:25:02,542
And the purpose of the new design language

358
00:25:02,843 --> 00:25:05,487
will be to highlight
different aspects of the system.

359
00:25:05,818 --> 00:25:09,439
It'll suppress some kinds of details
and emphasize other kinds of details.

360
00:25:12,446 --> 00:25:15,480
This is gonna be the third,
the most magical part of the course.

361
00:25:15,881 --> 00:25:19,202
We're gonna start out
by actually looking at the technology

362
00:25:19,553 --> 00:25:21,230
for building new computer languages

363
00:25:21,631 --> 00:25:27,089
and the first thing we're
gonna do is actually build in LISP...

364
00:25:28,318 --> 00:25:33,781
We're gonna express in LISP
the process of interpreting LISP itself.

365
00:25:34,135 --> 00:25:36,426
And that's gonna be
very sort of self-circular thing.

366
00:25:36,727 --> 00:25:39,496
There's a little mystical symbol
that has to do with that.

367
00:25:39,831 --> 00:25:43,229
We'll see that the process
of interpreting LISP is sort of...

368
00:25:44,040 --> 00:25:47,427
a giant wheel
of two processes, apply and eval,

369
00:25:47,839 --> 00:25:50,988
which sort of constantly
reduce expressions to each other.

370
00:25:52,051 --> 00:25:56,209
Now, we're gonna see also other magical
things. Here's another magical symbol.

371
00:25:56,980 --> 00:25:58,283
This is kind of the...

372
00:25:59,760 --> 00:26:00,984
This is sort of the Y-operator,

373
00:26:01,366 --> 00:26:06,185
which is in some sense the expression of
infinity inside our procedural language.

374
00:26:06,520 --> 00:26:07,922
We'll take a look at that.

375
00:26:08,224 --> 00:26:10,118
In any case this section of the course

376
00:26:10,448 --> 00:26:14,007
is called metalinguistic abstraction.

377
00:26:15,959 --> 00:26:22,968
By talking, abstracting by talking about

378
00:26:23,945 --> 00:26:26,562
how you construct new languages

379
00:26:29,830 --> 00:26:31,901
as I said we're gonna start out

380
00:26:32,420 --> 00:26:36,321
by looking at the process of
interpretation. We're gonna look at

381
00:26:36,822 --> 00:26:38,680
this apply/eval loop.

382
00:26:40,650 --> 00:26:41,840
and build LISP.

383
00:26:42,224 --> 00:26:44,021
Then just to show you
that this is very general

384
00:26:44,236 --> 00:26:47,907
we're gonna use exactly the same technology
to build a very different kind of language,

385
00:26:48,208 --> 00:26:50,294
a so-called logic programming language,

386
00:26:50,509 --> 00:26:53,081
where you don't really talk
about procedures at all

387
00:26:53,470 --> 00:26:55,369
that have inputs and outputs.
What you do is talk about

388
00:26:55,703 --> 00:26:58,535
relations between things.
And then finally

389
00:26:59,027 --> 00:27:00,526
we're gonna talk about how you

390
00:27:01,080 --> 00:27:05,198
implement these things very concretely
on a very simplest kind of machines.

391
00:27:05,499 --> 00:27:08,355
Even... we'll see something like this,

392
00:27:08,989 --> 00:27:11,718
which is... this is a picture of a chip

393
00:27:12,049 --> 00:27:16,204
which is the LISP interpreter
that we will be talking about,

394
00:27:16,680 --> 00:27:18,951
then in hardware.

395
00:27:19,823 --> 00:27:24,119
OK. Well, there's an outline
of the course, three big topics:

396
00:27:24,753 --> 00:27:29,846
Black-box abstraction, conventional
interfaces, metalinguistic abstraction.

397
00:27:31,067 --> 00:27:35,663
Well, let's take a break now
and then we'll get started.

398
00:28:03,802 --> 00:28:07,004
Well, let's actually
start in learning LISP now.

399
00:28:07,853 --> 00:28:10,086
Actually, we'll start up by learning
something much more important.

400
00:28:10,486 --> 00:28:12,613
Maybe, the very most
important thing in this course.

401
00:28:13,074 --> 00:28:14,525
Which is not LISP in particular,

402
00:28:14,869 --> 00:28:19,885
of course, but rather a general framework
for thinking about languages.

403
00:28:20,606 --> 00:28:24,409
I already alluded to when somebody tells
you they gonna show you a language,

404
00:28:24,809 --> 00:28:27,341
what you should say is:
alright, what I'd like you to tell me

405
00:28:27,685 --> 00:28:33,916
is what are the primitive elements?

406
00:28:37,444 --> 00:28:38,622
What does the language come with?

407
00:28:39,009 --> 00:28:43,328
Then, what are the ways
you put those together?

408
00:28:43,629 --> 00:28:47,984
What are the means of combination?

409
00:28:50,215 --> 00:28:53,905
What are the things that allow you
to take these primitive elements

410
00:28:54,383 --> 00:28:56,747
and build bigger things out of them?

411
00:28:57,775 --> 00:29:00,402
What are the ways
of putting things together?

412
00:29:01,175 --> 00:29:07,347
And then,
what are the means of abstraction?

413
00:29:08,018 --> 00:29:12,979
How do we take those complicated things

414
00:29:15,535 --> 00:29:16,624
and draw those boxes around them?

415
00:29:16,914 --> 00:29:18,143
How do we name them

416
00:29:18,463 --> 00:29:21,208
so that we can now use them
as if they were primitive elements

417
00:29:21,593 --> 00:29:25,934
in making still more complex things
and so on, and so on, and so on?

418
00:29:26,834 --> 00:29:29,609
So, when someone says to you:
Gee, I have a great new computer language!

419
00:29:30,563 --> 00:29:34,606
You don't say: How many characters
does it take to invert a matrix?

420
00:29:35,575 --> 00:29:36,934
Right? It's irrelevant.

421
00:29:37,284 --> 00:29:38,282
Right? What you say is:

422
00:29:38,607 --> 00:29:41,965
How, if the language
did not come with matrices built in

423
00:29:42,307 --> 00:29:45,510
or with something else built in,
how could I then build that thing?

424
00:29:45,887 --> 00:29:48,246
What are the means of combination
which would allow me to do that?

425
00:29:48,547 --> 00:29:50,656
And then,
what are the means of the abstraction,

426
00:29:51,491 --> 00:29:53,708
which allow me
then to use those as elements

427
00:29:54,009 --> 00:29:56,782
in making more complicated things yet.

428
00:29:58,904 --> 00:30:01,485
Well, we're gonna see
that LISP has some primitive data

429
00:30:02,103 --> 00:30:04,593
and some primitive procedures.

430
00:30:05,375 --> 00:30:08,370
In fact let's really start.

431
00:30:08,771 --> 00:30:13,069
And here's a piece of
primitive data in LISP. Let's see...

432
00:30:13,741 --> 00:30:16,138
Number 3.

433
00:30:16,682 --> 00:30:19,417
Actually, from being very pedantic
that's not the number 3.

434
00:30:19,857 --> 00:30:25,516
That's some symbol that represents...
plays those concepts of the number 3.

435
00:30:26,560 --> 00:30:33,014
And here's another...
here's some more primitive data in LISP.

436
00:30:34,767 --> 00:30:39,733
Seventeen point four.
Actually, some representation of 17.4.

437
00:30:40,844 --> 00:30:45,649
And, here's another one. Five.

438
00:30:46,490 --> 00:30:49,624
Here's another
primitive object that's built in LISP.

439
00:30:51,610 --> 00:30:56,477
Addition. Actually, if we used the same
kind of pedantic, this is a name

440
00:30:56,870 --> 00:30:59,528
for the primitive method
that's adding things.

441
00:31:00,129 --> 00:31:02,207
Just like this is a name
for what played those number 3,

442
00:31:02,508 --> 00:31:09,145
this is a name for what played
those concept of how you add things.

443
00:31:10,137 --> 00:31:11,714
So those are some primitive elements.

444
00:31:12,066 --> 00:31:13,813
I can put them together.

445
00:31:14,114 --> 00:31:18,304
I can say, gee,
what's the sum of 3 and 17.4 and 5?

446
00:31:18,608 --> 00:31:24,071
The way I do that is to say let's apply

447
00:31:24,975 --> 00:31:31,494
the sum operator to these three numbers.
And I should get what? 8, 17,.. 25.4.

448
00:31:34,107 --> 00:31:38,152
So, I should be able to ask LISP
what the value of this is.

449
00:31:38,692 --> 00:31:41,501
And it'll return 25.4.

450
00:31:43,117 --> 00:31:47,199
Let's introduce some names.
This thing that I typed

451
00:31:49,745 --> 00:31:55,242
is called the combination.

452
00:31:56,555 --> 00:32:02,744
And a combination consists in general
of applying an operator

453
00:32:03,313 --> 00:32:05,420
(so, this is an operator)

454
00:32:09,660 --> 00:32:15,408
to some operands
(these are the operands).

455
00:32:21,429 --> 00:32:23,309
And of course
I can make more complex things.

456
00:32:23,610 --> 00:32:28,623
The reason I can get complexity out of
this is because the operands themselves

457
00:32:29,267 --> 00:32:30,972
in general can be combinations.

458
00:32:31,273 --> 00:32:33,133
So, for instance, I could say what is

459
00:32:33,534 --> 00:32:41,190
the sum of 3 and the product of 5 and 6,

460
00:32:41,749 --> 00:32:44,264
and 8, and 2.

461
00:32:45,100 --> 00:32:47,158
And I should get, let's see...

462
00:32:47,514 --> 00:32:54,849
30, 40,.. 43.
So LISP should tell me that that's 43.

463
00:32:55,785 --> 00:32:58,387
Forming combinations...

464
00:32:58,920 --> 00:33:02,724
well, is the basic means of combination
that we'll be looking in.

465
00:33:04,341 --> 00:33:09,302
And then, well, you see some syntax here.

466
00:33:10,289 --> 00:33:14,801
LISP uses what is called prefix notation

467
00:33:16,259 --> 00:33:20,197
which means that the operator...

468
00:33:21,347 --> 00:33:26,411
is written to the left of the operands.
It's just a convention.

469
00:33:27,495 --> 00:33:29,610
And note that it's fully parenthesized.

470
00:33:29,943 --> 00:33:32,013
And the parentheses
make it completely unambiguous.

471
00:33:32,292 --> 00:33:34,460
So by looking at this I can see that

472
00:33:35,824 --> 00:33:41,162
there's the operator and there are
one,.. two,.. three,.. four operands.

473
00:33:42,817 --> 00:33:47,906
And I can see that the second operand
here is itself some combination,

474
00:33:48,876 --> 00:33:51,621
that has one operator and two operands.

475
00:33:52,445 --> 00:33:54,211
Parentheses in LISP are a little bit...

476
00:33:54,585 --> 00:33:57,354
well, are very unlike
parentheses in conventional mathematics.

477
00:33:57,611 --> 00:34:00,122
In mathematics we sort of
use them to mean grouping.

478
00:34:01,157 --> 00:34:03,475
And it sort of doesn't hurt if sometimes
you leave out parentheses if

479
00:34:03,792 --> 00:34:05,447
people understand that that's a group.

480
00:34:05,769 --> 00:34:08,313
And in general it doesn't hurt
if put in extra parentheses

481
00:34:08,628 --> 00:34:11,706
because that maybe makes the grouping
more distinct. LISP is not like that!

482
00:34:12,880 --> 00:34:18,952
In LISP you can't leave out parentheses.
And you can't put in extra parentheses.

483
00:34:19,153 --> 00:34:22,673
'Cause putting in parentheses
always means exactly and precisely

484
00:34:23,225 --> 00:34:25,809
this is a combination,

485
00:34:26,168 --> 00:34:28,820
which has meaning
applying operator to operands.

486
00:34:29,140 --> 00:34:30,673
And if I left this out,..

487
00:34:31,263 --> 00:34:34,239
if I left those parentheses out
it would mean something else.

488
00:34:35,249 --> 00:34:36,950
In fact, the way to think about this

489
00:34:37,251 --> 00:34:40,097
is really what I'm doing
when I write something like this

490
00:34:40,439 --> 00:34:41,974
is writing a tree.

491
00:34:42,371 --> 00:34:44,372
So, this combination is a tree

492
00:34:44,729 --> 00:34:48,294
that has a plus, and then a 3,

493
00:34:48,939 --> 00:34:54,010
and then something else,
and then 8, and a 2.

494
00:34:54,345 --> 00:34:58,455
And then this something else here
is itself a little subtree

495
00:34:59,526 --> 00:35:03,154
that has a star, and a 5, and a 6.

496
00:35:03,685 --> 00:35:06,487
And the way to think of that
is really what's going on

497
00:35:07,237 --> 00:35:12,917
are rewriting these trees,
and parentheses are just a way

498
00:35:13,268 --> 00:35:17,625
to write this two-dimensional structure
as a linear character string.

499
00:35:18,868 --> 00:35:21,189
Because when LISP first started

500
00:35:21,590 --> 00:35:23,632
then people had teletypes
or punchcards or whatever...

501
00:35:23,953 --> 00:35:25,248
This was more convenient.

502
00:35:25,845 --> 00:35:30,458
Maybe if LISP started today
the syntax of LISP would look like that.

503
00:35:31,891 --> 00:35:35,547
Well, let's look at what that
actually looks like on the computer.

504
00:35:36,382 --> 00:35:40,569
Here I have a LISP
interaction set up. There's an editor.

505
00:35:40,970 --> 00:35:44,721
And on top I'm gonna type some values
and ask LISP what they are.

506
00:35:45,074 --> 00:35:48,732
So, for instance I can say to LISP
what's the value of that symbol?

507
00:35:49,313 --> 00:35:53,278
That's 3. And I ask LISP to evaluate it.
And now you see LISP has returned

508
00:35:53,899 --> 00:35:57,375
on the bottom
and said oh, yeah, that's 3.

509
00:35:57,631 --> 00:36:08,139
Or I can say what's the sum of 3 and 4
and 8? What's that combination?

510
00:36:08,968 --> 00:36:11,852
And I ask LISP to evaluate it.

511
00:36:13,776 --> 00:36:15,853
That's 15.

512
00:36:16,401 --> 00:36:20,736
Or I can type in something more
complicated. I can say what's the sum...

513
00:36:21,175 --> 00:36:24,931
of the product of 3...

514
00:36:25,369 --> 00:36:33,847
and the sum of 7 and 19.5...

515
00:36:34,993 --> 00:36:36,150
And you notice here

516
00:36:36,548 --> 00:36:38,530
that LISP has something built in
that helps me keep track

517
00:36:38,876 --> 00:36:41,724
of all these parentheses. Watch
as I type the next close parenthesis

518
00:36:42,100 --> 00:36:45,365
which is gonna close
the combination starting with the star.

519
00:36:45,728 --> 00:36:47,277
The opening one will flash.

520
00:36:47,696 --> 00:36:49,875
There. I'll rub those out and do it again...

521
00:36:50,133 --> 00:36:52,787
Type close
and you see that closes the plus.

522
00:36:53,428 --> 00:36:56,793
Close again that closes the star.

523
00:36:57,657 --> 00:37:00,916
Now I'm back to the sum
and maybe I'm gonna add that all to 4

524
00:37:01,480 --> 00:37:04,226
That closes the plus,
now I have a complete combination.

525
00:37:04,678 --> 00:37:08,545
And I can ask LISP for the value
of that. That kind of paren balancing

526
00:37:09,185 --> 00:37:12,763
is something that's built into a lot
of LISP systems to help you keep track

527
00:37:13,148 --> 00:37:16,504
because it is kind of boring
just by hand doing all this parentheses.

528
00:37:16,886 --> 00:37:20,732
There's another kind of convention
for keeping track of parentheses.

529
00:37:21,033 --> 00:37:23,898
Let me write another
complicated combination.

530
00:37:24,704 --> 00:37:27,153
Let's say the sum of

531
00:37:27,695 --> 00:37:31,642
the product of 3 and 5,

532
00:37:32,819 --> 00:37:36,830
and add that to something and now
what I'm gonna do is I'm gonna indent so

533
00:37:37,117 --> 00:37:39,630
that the operands are written vertically

534
00:37:40,010 --> 00:37:41,869
Let's the sum of that and the product

535
00:37:42,287 --> 00:37:49,335
of 47 and... let's say the product of 47

536
00:37:50,047 --> 00:37:57,345
with the difference of 20 and 6.8
(that means subtract 6.8 from 20).

537
00:37:58,462 --> 00:38:03,163
Now you see the parentheses close
close the minus, close the star...

538
00:38:03,793 --> 00:38:04,949
And now let's get another operator...

539
00:38:05,292 --> 00:38:07,332
You see,
the LISP editor here is indenting

540
00:38:07,707 --> 00:38:12,290
to the right position automatically
to help me keep track.

541
00:38:12,726 --> 00:38:18,326
Again, I'll close that list parentheses
again, you see, it balances the plus

542
00:38:19,803 --> 00:38:22,970
Right, now I can say
what's the value of that?

543
00:38:23,614 --> 00:38:27,448
Right, so, those two things:

544
00:38:27,844 --> 00:38:30,604
indenting to the right level,
which is called pretty printing,

545
00:38:31,357 --> 00:38:33,587
and flashing parentheses

546
00:38:33,899 --> 00:38:36,579
are two things that a lot of
LISP systems have built in

547
00:38:36,869 --> 00:38:39,491
to help you keep track
and you should learn how to use them.

548
00:38:41,524 --> 00:38:43,238
OK. Well, those are the primitives.

549
00:38:44,669 --> 00:38:48,151
There's a means of combination.
Now let's go to the means of abstraction.

550
00:38:49,258 --> 00:38:53,404
I'd like to be able to take the idea
that I do some combination like this

551
00:38:53,750 --> 00:38:56,842
and abstract it and give it a simple
name so I can use that as an element,

552
00:38:57,243 --> 00:39:00,510
and I do that in LISP with define.

553
00:39:00,910 --> 00:39:07,969
So I could say for example define A

554
00:39:08,802 --> 00:39:15,713
to be the product of 5 and 5.

555
00:39:17,720 --> 00:39:21,334
And now I could say for example to LISP

556
00:39:21,964 --> 00:39:26,655
what is the product of A and A?

557
00:39:27,258 --> 00:39:30,494
And this should be 25,
and this should be 625.

558
00:39:31,544 --> 00:39:35,734
And then crucial thing I can now use A.

559
00:39:36,135 --> 00:39:37,836
Here I've used it in the combination,

560
00:39:38,249 --> 00:39:43,157
but I could use that in other more
complicated things that I name in turn.

561
00:39:43,508 --> 00:39:48,379
So I could say define B

562
00:39:49,554 --> 00:39:57,192
to be the sum of A and product of 5 and A.

563
00:39:59,409 --> 00:40:01,017
... and close the plus...

564
00:40:02,939 --> 00:40:06,202
Let's take a look at that on the
computer and see how that looks.

565
00:40:07,992 --> 00:40:10,333
So, well, I'll just type
what wrote on the board.

566
00:40:10,704 --> 00:40:16,878
I could say define A

567
00:40:17,609 --> 00:40:21,817
to be the product of 5 and 5.

568
00:40:24,023 --> 00:40:25,334
I'll tell that to LISP

569
00:40:25,713 --> 00:40:28,707
and notice what LISP responded
there with with an A in the bottom.

570
00:40:29,148 --> 00:40:31,082
In general
when you type in a definition of LISP

571
00:40:31,524 --> 00:40:34,887
it responds with the symbol being defined.

572
00:40:35,561 --> 00:40:41,600
Now, I could say to LISP
what is the product of A and A?

573
00:40:42,538 --> 00:40:44,549
So it says 625.

574
00:40:45,728 --> 00:40:50,321
I can define B

575
00:40:51,324 --> 00:40:57,585
to be the sum of A and the product

576
00:40:57,986 --> 00:41:04,344
of 5 and A, close the paren,
close the star, close the plus.

577
00:41:04,752 --> 00:41:06,835
Close the define.

578
00:41:07,621 --> 00:41:09,060
LISP says:
OK. B.

579
00:41:09,337 --> 00:41:13,850
There on the bottom. And now
I can say to LISP what's the value of B?

580
00:41:17,010 --> 00:41:20,018
And I can say something more
complicated, like what's the sum

581
00:41:20,367 --> 00:41:26,205
of A and the quotient of B and 5?

582
00:41:26,582 --> 00:41:30,032
That slash is divide,
another primitive operator.

583
00:41:30,379 --> 00:41:33,001
I've divided B by 5 and added it to A.

584
00:41:33,502 --> 00:41:35,774
LISP says:
OK. That's 55.

585
00:41:36,509 --> 00:41:38,152
Alright. So, there's what it looks like.

586
00:41:39,786 --> 00:41:42,913
There's the basic means
of defining something.

587
00:41:43,355 --> 00:41:49,341
It's the simplest kind of naming,
but it's not really very powerful.

588
00:41:49,812 --> 00:41:53,157
See, what I'd really like to name...
I'm gonna talk about general methods...

589
00:41:53,498 --> 00:41:55,848
I'd like to name all the general idea

590
00:41:56,313 --> 00:42:00,626
that for example I could multiply 5 by 5

591
00:42:03,213 --> 00:42:06,141
... or 6 by 6,..

592
00:42:06,419 --> 00:42:12,719
...  or 1001 by 1001,

593
00:42:14,653 --> 00:42:17,531
... or 1001.7 by 1001.7

594
00:42:17,830 --> 00:42:20,624
Or I'd like to be able
to name the general idea

595
00:42:22,127 --> 00:42:24,408
of multiplying something by itself.

596
00:42:28,289 --> 00:42:30,105
We know that it is
that's called squaring.

597
00:42:31,558 --> 00:42:33,844
And the way I can do that in LISP

598
00:42:34,463 --> 00:42:36,827
is I can say

599
00:42:37,576 --> 00:42:40,790
define...

600
00:42:43,371 --> 00:42:49,465
to square some thing X

601
00:42:51,907 --> 00:42:56,974
multiply X by itself.

602
00:42:57,849 --> 00:43:00,173
And then, having done that, I could say

603
00:43:00,643 --> 00:43:08,068
to LISP for example what's
the square of 10? And LISP will say 100.

604
00:43:11,914 --> 00:43:14,472
Let's actually look at that
a little more closely.

605
00:43:15,337 --> 00:43:19,702
There's the definition of square.
To square something

606
00:43:20,258 --> 00:43:23,260
multiply it by itself.

607
00:43:23,661 --> 00:43:25,688
You see this X here.

608
00:43:26,284 --> 00:43:29,622
Right? That X is kind of a pronoun which
is the something that I'm gonna square.

609
00:43:31,275 --> 00:43:37,572
And what I do is I multiply X by itself.

610
00:43:44,026 --> 00:43:47,703
OK. So, there's a notation
for defining a procedure.

611
00:43:48,104 --> 00:43:50,336
Actually this is a little bit confusing,

612
00:43:50,755 --> 00:43:55,214
because this is sort of how I
might use square and I say square of X,

613
00:43:55,600 --> 00:43:56,992
or square of 10,

614
00:43:57,463 --> 00:44:01,836
but it's not making it very clear
that I'm actually naming something.

615
00:44:02,985 --> 00:44:05,213
So, let me write this
definition in another way

616
00:44:05,609 --> 00:44:08,026
that makes a little bit more clear
that I'm naming something.

617
00:44:08,427 --> 00:44:14,386
I'll say define square

618
00:44:17,984 --> 00:44:20,709
to be...

619
00:44:22,281 --> 00:44:29,820
lambda of X times X X.

620
00:44:36,202 --> 00:44:38,563
Here I'm naming something square.

621
00:44:39,177 --> 00:44:42,513
Just like over here
I'm naming something A.

622
00:44:43,057 --> 00:44:44,435
The thing that I'm naming square...

623
00:44:44,831 --> 00:44:48,642
Here I named... the thing that I named A
was the value of this combination.

624
00:44:49,179 --> 00:44:52,928
Here the thing that I'm naming square
is this thing that begins with lambda

625
00:44:53,354 --> 00:44:57,471
and lambda is LISP's way
of saying 'make a procedure'.

626
00:45:00,097 --> 00:45:03,080
Let's look at that
more closely on a slide.

627
00:45:03,925 --> 00:45:11,267
The way I read that definition is to say
I define square to be make a procedure

628
00:45:12,602 --> 00:45:13,772
(that's what the lambda is)

629
00:45:14,151 --> 00:45:17,234
Make a procedure
with an argument named X

630
00:45:18,919 --> 00:45:23,838
and what it does is return
the result of multiplying X by itself.

631
00:45:24,871 --> 00:45:29,562
Now, in general we're gonna be using...

632
00:45:30,572 --> 00:45:32,846
We're gonna be using
this top form of defining.

633
00:45:33,386 --> 00:45:34,884
This is 'cause
it's a little bit more convenient.

634
00:45:35,185 --> 00:45:38,526
But don't lose sight
of the fact that it's really this.

635
00:45:38,835 --> 00:45:41,233
In fact as far as
the LISP interpreter is concerned

636
00:45:41,578 --> 00:45:45,829
there's no difference between
typing this to it and typing this to it.

637
00:45:46,443 --> 00:45:48,995
And there's a word for that:

638
00:45:50,650 --> 00:45:53,724
Syntactic sugar.

639
00:45:54,416 --> 00:45:56,888
What syntactic sugar means it's having

640
00:45:57,784 --> 00:46:01,058
somewhat more convenient
surface forms for typing something.

641
00:46:01,921 --> 00:46:06,416
So, this is just really syntactic sugar
for this underlying thing with the lambda.

642
00:46:07,257 --> 00:46:09,752
And the reason you should
remember that is don't forget

643
00:46:10,128 --> 00:46:13,875
that when I write something like this
I'm really naming something.

644
00:46:14,236 --> 00:46:15,896
I'm naming something square

645
00:46:16,202 --> 00:46:18,394
and this something that
I'm naming square is a procedure

646
00:46:18,778 --> 00:46:20,560
that's getting constructed.

647
00:46:21,317 --> 00:46:23,823
OK. Well, let's look at that
on the computer too.

648
00:46:24,739 --> 00:46:27,970
So, I'll come in and I'll say define

649
00:46:29,383 --> 00:46:36,461
square of X to be times X X.

650
00:46:39,475 --> 00:46:42,174
And I can...

651
00:46:49,310 --> 00:46:52,461
OK. I'll tell LISP that.

652
00:46:53,325 --> 00:46:57,952
It says square as I have named
something square and having done that,

653
00:46:58,473 --> 00:47:04,230
I can ask LISP
for what's the square of 1001.

654
00:47:05,016 --> 00:47:09,559
Or in general I could say

655
00:47:10,136 --> 00:47:18,448
what's the square of the sum of 5 and 7?

656
00:47:22,700 --> 00:47:24,670
Right? Square of 12 is 144.

657
00:47:25,124 --> 00:47:28,240
Or I can use square itself
as an element in some combination.

658
00:47:28,641 --> 00:47:39,179
I can say what's the sum of
the square of 3 and the square of 4?

659
00:47:41,293 --> 00:47:44,610
Right? 9 and 16 is 25.

660
00:47:45,129 --> 00:47:49,843
Or I can use square as an element
in some much more complicated thing.

661
00:47:50,344 --> 00:48:01,533
I can say what's the square of
the square of the square of 1001?

662
00:48:07,624 --> 00:48:10,746
And here's the square
of the square of the square of 1001.

663
00:48:11,238 --> 00:48:16,941
Well, I can say to LISP what is square
itself? What's the value of that?

664
00:48:17,358 --> 00:48:19,633
And LISP returns some conventional way

665
00:48:20,077 --> 00:48:21,838
of telling me that that's a procedure

666
00:48:22,339 --> 00:48:23,934
that's compound procedure square.

667
00:48:24,257 --> 00:48:26,367
And the value of square is

668
00:48:26,895 --> 00:48:30,718
this procedure. And the things
with the stars and the brackets

669
00:48:31,101 --> 00:48:34,964
are just LISP's
conventional way of describing that.

670
00:48:36,287 --> 00:48:38,417
OK. Let's look at...

671
00:48:39,295 --> 00:48:41,305
at two more examples of defining.

672
00:48:44,714 --> 00:48:46,767
Here are two more procedures.

673
00:48:47,216 --> 00:48:52,927
I can define the average of X and Y
to be the sum of X and Y divided by 2.

674
00:48:54,520 --> 00:49:01,098
Or, having had average and square,

675
00:49:01,601 --> 00:49:04,453
I can use that to talk about
the mean square of something.

676
00:49:04,837 --> 00:49:09,995
Which is the average
of the square of X and the square of Y.

677
00:49:10,719 --> 00:49:12,639
So, for example having done that,

678
00:49:13,089 --> 00:49:15,865
I could say what's the mean square

679
00:49:22,192 --> 00:49:30,658
of 2 and 3? And I should get
the average of 4 and 9, which is 6.5.

680
00:49:32,815 --> 00:49:34,209
The key thing here

681
00:49:34,965 --> 00:49:38,730
is that having defined square
I can use it as if it were primitive.

682
00:49:41,413 --> 00:49:44,072
So, if we look here on the slide...

683
00:49:44,473 --> 00:49:45,831
If I look at mean-square...

684
00:49:47,233 --> 00:49:49,708
The person defining mean-square

685
00:49:50,155 --> 00:49:52,433
doesn't have to know at this point

686
00:49:52,768 --> 00:49:55,788
whether square was
something built into the language

687
00:49:56,896 --> 00:49:59,211
or whether it was a procedure
that was defined.

688
00:49:59,649 --> 00:50:01,910
And that's key thing in LISP.

689
00:50:02,280 --> 00:50:06,460
That you do not
make arbitrary distinctions

690
00:50:06,866 --> 00:50:09,350
between things that happen
to be primitive in the language

691
00:50:09,779 --> 00:50:12,382
and things that happen to be built in.

692
00:50:12,808 --> 00:50:16,218
Person using it shouldn't even have
to know. So the things you construct

693
00:50:16,520 --> 00:50:19,342
get used with all the power and
flexibility as if they were primitives.

694
00:50:19,743 --> 00:50:23,010
In fact you can drive that home by
looking on the computer one more time.

695
00:50:24,608 --> 00:50:28,952
We talked about plus. And in fact
if I come here on the computer screen

696
00:50:29,528 --> 00:50:32,756
and say what is the value of plus?

697
00:50:34,176 --> 00:50:35,836
Notice what LISP types out.

698
00:50:36,192 --> 00:50:38,987
On the bottom there
it typed out compound procedure +.

699
00:50:39,887 --> 00:50:42,420
Because in this system it turns out

700
00:50:42,821 --> 00:50:45,562
that the addition operator
is itself a compound procedure.

701
00:50:45,885 --> 00:50:47,735
And if I didn't just typed that in
you'd never know that

702
00:50:48,092 --> 00:50:49,929
and it wouldn't make any
difference anyway. We don't care.

703
00:50:50,230 --> 00:50:53,394
It's below the level of the
abstraction that we're dealing with.

704
00:50:54,096 --> 00:50:57,826
So, the key thing is you can not tell,..
should not be able to tell

705
00:50:58,647 --> 00:51:02,190
in general the difference
between things that are built in

706
00:51:02,572 --> 00:51:03,572
and things that are compound.

707
00:51:03,868 --> 00:51:05,441
Why is that?
Because the things that are compound

708
00:51:05,758 --> 00:51:08,232
have an abstraction wrapper
wrapped around them.

709
00:51:09,112 --> 00:51:11,901
OK. We've seen almost
all the elements of LISP now.

710
00:51:12,658 --> 00:51:14,121
There's only one more we have to look at.

711
00:51:14,469 --> 00:51:16,216
And that is how to make a case analysis.

712
00:51:16,583 --> 00:51:18,064
Let me show you what I mean.

713
00:51:18,792 --> 00:51:20,399
We might wanna think about the

714
00:51:21,098 --> 00:51:23,825
mathematical definition
of the absolute value function.

715
00:51:24,203 --> 00:51:27,807
I might say the absolute value of X

716
00:51:28,624 --> 00:51:31,227
is the function which has the property

717
00:51:31,682 --> 00:51:34,366
that it's negative of X

718
00:51:35,639 --> 00:51:37,409
for X less than zero,

719
00:51:37,915 --> 00:51:41,423
it's zero for X equal to zero,

720
00:51:42,398 --> 00:51:47,114
and it's X for X greater than zero.

721
00:51:49,125 --> 00:51:51,199
And LISP has a way of making case analysis.

722
00:51:51,546 --> 00:51:53,816
Let me define for you absolute value.

723
00:51:55,499 --> 00:52:00,737
Say define the absolute value of X is

724
00:52:01,485 --> 00:52:06,438
conditional... This means
case analysis - cond.

725
00:52:09,272 --> 00:52:14,608
If X is less than zero

726
00:52:15,288 --> 00:52:19,736
the answer is negate X.

727
00:52:22,699 --> 00:52:26,640
Right, what I've written here
is a clause. This is a...

728
00:52:28,687 --> 00:52:32,199
This something is a conditional clause.

729
00:52:34,130 --> 00:52:41,602
And it has two parts.
This part here is a predicate,..

730
00:52:44,112 --> 00:52:45,719
condition, that's a condition.

731
00:52:46,020 --> 00:52:48,060
The condition is expressed
by something called a predicate.

732
00:52:48,456 --> 00:52:50,928
And a predicate in LISP
is some sort of thing

733
00:52:51,331 --> 00:52:53,050
that returns either true or false.

734
00:52:53,478 --> 00:52:56,594
And you see LISP has
a primitive procedure less than,

735
00:52:57,225 --> 00:52:59,587
that tests
whether something is true or false.

736
00:53:00,518 --> 00:53:02,555
And the other part of a clause

737
00:53:03,491 --> 00:53:06,676
is an action or a thing to do

738
00:53:07,020 --> 00:53:09,677
in the case where that's true.
And here what I'm doing is negating X.

739
00:53:10,002 --> 00:53:14,063
The negation operator, well, the minus
sign in LISP is a little bit funny.

740
00:53:14,492 --> 00:53:17,607
If there are two or more arguments...

741
00:53:18,007 --> 00:53:21,411
if there are two arguments then it
subtracts the second one from the first.

742
00:53:21,781 --> 00:53:23,996
We saw that. And if there's
one argument then it negates it.

743
00:53:25,025 --> 00:53:27,297
So, this corresponds to that.

744
00:53:27,686 --> 00:53:32,833
And there's another kind of clause. It
says in the case where X is equal to 0

745
00:53:34,458 --> 00:53:36,835
the answer is zero.

746
00:53:37,584 --> 00:53:44,684
And in the case where X is
greater than zero the answer is X.

747
00:53:45,419 --> 00:53:49,090
Close that clause, close the cond,
close the definition.

748
00:53:49,543 --> 00:53:50,772
There's a definition of absolute value

749
00:53:51,173 --> 00:53:52,511
and you see that it's a case analysis

750
00:53:52,868 --> 00:53:55,881
that looks very much like the
case analysis you use in mathematics.

751
00:53:57,685 --> 00:54:02,847
OK. There's a somewhat different way
of writing a restricted case analysis.

752
00:54:03,104 --> 00:54:06,421
Often you have a case analysis
where you only have one case.

753
00:54:06,905 --> 00:54:08,304
Or you test something and

754
00:54:08,651 --> 00:54:10,767
depending on whether
it's true or false you do something.

755
00:54:13,020 --> 00:54:17,115
Here's another definition of absolute
value which looks almost the same,

756
00:54:17,774 --> 00:54:22,707
which says if X is less then zero,
the result is negate X,

757
00:54:24,321 --> 00:54:25,823
otherwise the answer is X.

758
00:54:26,214 --> 00:54:30,086
We'll be using IF a lot. But again
the thing to remember is that this form

759
00:54:30,487 --> 00:54:32,695
of absolute value
that you're looking at here

760
00:54:34,004 --> 00:54:36,945
and then this one over here
that I wrote on the board

761
00:54:37,486 --> 00:54:38,846
are essentially the same.

762
00:54:39,140 --> 00:54:41,747
And IF and COND are
whichever way you like it.

763
00:54:42,048 --> 00:54:44,352
You can think of COND
as syntactic sugar for IF,

764
00:54:44,933 --> 00:54:46,819
or you can think of IF
as syntactic sugar for COND,

765
00:54:47,267 --> 00:54:48,670
and it doesn't make any difference.

766
00:54:49,157 --> 00:54:51,032
Person implementing
a LISP system will pick one

767
00:54:51,333 --> 00:54:52,773
and implement the other in terms of that,

768
00:54:53,116 --> 00:54:55,054
and it doesn't matter which one he pick.

769
00:55:02,534 --> 00:55:04,978
OK. Why don't we break now
and then take some questions.

770
00:55:05,572 --> 00:55:07,213
How come...

771
00:55:08,079 --> 00:55:10,443
sometimes when I write define

772
00:55:11,118 --> 00:55:13,236
I put an open paren here

773
00:55:14,181 --> 00:55:16,404
and say define open paren
some thing or other,

774
00:55:16,794 --> 00:55:20,907
and sometimes when I write this
I don't put an open paren?

775
00:55:22,225 --> 00:55:24,354
OK. The answer is...

776
00:55:25,298 --> 00:55:29,044
this particular form of define
where you say define some expression

777
00:55:29,563 --> 00:55:32,267
is this very special thing
for defining procedures.

778
00:55:33,470 --> 00:55:40,727
But again what it really means is I'm
defining this symbol square to be that.

779
00:55:41,290 --> 00:55:45,942
So, the way you should think about it is
what define does is you write define

780
00:55:47,034 --> 00:55:49,709
and then second thing you write
is this symbol here, no open paren,

781
00:55:50,199 --> 00:55:51,653
this symbol you're defining.

782
00:55:52,111 --> 00:55:57,182
And what you're defining it to be...
that's like here... and like here...

783
00:55:57,586 --> 00:56:00,578
That's the sort of the
basic way you use define

784
00:56:01,094 --> 00:56:03,556
and then there's
the special syntactic trick,

785
00:56:04,214 --> 00:56:07,399
which allows you to define
procedures that look like this.

786
00:56:08,032 --> 00:56:14,746
So, the difference is it's whether
or not you're defining a procedure.

787
00:56:38,089 --> 00:56:42,058
Well, believe it or not,
you actually now know enough LISP

788
00:56:42,700 --> 00:56:45,402
to write essentially
any numerical procedure,

789
00:56:46,039 --> 00:56:49,115
that you'd write in a language
like Fortran or Basic or whatever,

790
00:56:49,555 --> 00:56:51,241
well, essentially any other language.

791
00:56:52,034 --> 00:56:54,681
You probably think
that's not believable, right?

792
00:56:55,028 --> 00:56:57,785
Because you know that these languages
have things like for statements

793
00:56:58,239 --> 00:57:00,397
and do...until/while or something.

794
00:57:00,950 --> 00:57:04,795
But we don't really need any of that.

795
00:57:05,158 --> 00:57:07,151
We're not gonna use
any of that in this course.

796
00:57:08,192 --> 00:57:12,935
Let me show you
by again looking back at square root.

797
00:57:13,336 --> 00:57:16,124
Let's go back to this
square root algorithm

798
00:57:17,188 --> 00:57:19,531
of Heron of Alexandria.
Remember what that said?

799
00:57:19,983 --> 00:57:26,589
It said to find an approximation to
the square root of X you make a guess,

800
00:57:27,307 --> 00:57:32,022
you improve that guess by averaging
the guess and X over the guess,

801
00:57:32,754 --> 00:57:35,993
you keep improving that
until the guess is good enough.

802
00:57:36,590 --> 00:57:38,177
And I already alluded to the idea.

803
00:57:38,517 --> 00:57:42,235
The idea is that
if the initial guess that she took...

804
00:57:42,972 --> 00:57:46,702
if that initial guess was actually
equal to the square root of X,

805
00:57:47,117 --> 00:57:50,634
then G here would be equal to X over G.

806
00:57:52,762 --> 00:57:55,159
So if you hit the square root
averaging wouldn't change it.

807
00:57:55,560 --> 00:57:59,865
IF the G that you pick was larger
than the square root of X

808
00:58:00,255 --> 00:58:02,573
then X/G would be smaller
then the square root of X,

809
00:58:03,122 --> 00:58:07,574
so that when you average G and X/G
you get something in between.

810
00:58:08,945 --> 00:58:12,663
Right? So, if you pick a G that's too
small, your answer will be too large.

811
00:58:13,074 --> 00:58:14,954
If you pick a G that's too large...

812
00:58:16,192 --> 00:58:18,889
if the G is larger than the square
root of X then X/G will be smaller

813
00:58:19,190 --> 00:58:20,653
than the square root of X.

814
00:58:21,090 --> 00:58:23,801
So, averaging always
gives you something in between

815
00:58:24,302 --> 00:58:28,587
and then it's not quite trivial
but it's possible to show that in fact

816
00:58:29,263 --> 00:58:31,255
if G misses
the square root of X by a little bit

817
00:58:31,682 --> 00:58:35,599
the average of G and X/G
will actually keep getting closer

818
00:58:36,682 --> 00:58:38,923
to the square root of X.
So if you keep doing this enough

819
00:58:39,350 --> 00:58:42,657
you'll eventually get as close
as you want and there's another fact

820
00:58:42,958 --> 00:58:47,635
that you can always start out this
process by using 1 as an initial guess,

821
00:58:49,168 --> 00:58:51,498
and it will always converge
to the square root of X.

822
00:58:52,107 --> 00:58:56,297
Right? So, that is method of successive
averaging due to Heron of Alexandria.

823
00:58:56,620 --> 00:58:59,311
Let's write it in LISP.

824
00:58:59,812 --> 00:59:03,363
Well, the central idea is

825
00:59:03,912 --> 00:59:07,463
what does it mean to try a guess
for the square root of X?

826
00:59:08,295 --> 00:59:10,672
Let's write that. So we'll say

827
00:59:11,495 --> 00:59:13,624
define...

828
00:59:15,292 --> 00:59:21,469
to try a guess

829
00:59:23,227 --> 00:59:25,296
for the square root of X...

830
00:59:26,152 --> 00:59:33,059
What do we do?
We'll say if the guess is good enough...

831
00:59:38,539 --> 00:59:45,199
If the guess is good enough
to be a guess for the square root of X,

832
00:59:46,375 --> 00:59:50,952
then as an answer we'll take the guess.

833
00:59:51,536 --> 00:59:57,016
Otherwise we will try the improved guess.

834
00:59:58,565 --> 01:00:02,163
We'll improve that guess

835
01:00:02,772 --> 01:00:04,671
for the square root of X

836
01:00:05,176 --> 01:00:09,081
and will try that
as a guess for the square root of X.

837
01:00:09,440 --> 01:00:12,732
... close the try,
close the if, close the define.

838
01:00:13,255 --> 01:00:15,029
So, that's how we try a guess.

839
01:00:15,641 --> 01:00:19,762
And then the next part of the process
said in order to compute square roots

840
01:00:21,192 --> 01:00:23,789
we'll say define

841
01:00:25,539 --> 01:00:29,927
to compute the square root of X

842
01:00:30,328 --> 01:00:36,187
we will try 1 as a guess
for the square root of X.

843
01:00:37,545 --> 01:00:39,405
Well, we have to define
a couple more things.

844
01:00:40,019 --> 01:00:45,379
Well, we have to say how is a guess good
enough and how do we improve a guess.

845
01:00:45,803 --> 01:00:49,532
So let's look at that.
The algorithm to improve the guess

846
01:00:50,178 --> 01:00:55,813
Right? To improve a guess
for the square root of X we average...

847
01:00:56,275 --> 01:00:58,359
That was the algorithm...
We average the guess

848
01:00:58,818 --> 01:01:04,354
with the quotient of dividing X by the
guess. That's how we improve the guess.

849
01:01:05,678 --> 01:01:08,366
And to tell whether a guess is good
enough for we have to decide something.

850
01:01:08,783 --> 01:01:11,018
This is supposed to be a guess
for the square root of X.

851
01:01:11,319 --> 01:01:12,923
So, one possible thing you can do

852
01:01:13,281 --> 01:01:15,876
is say when you
take that guess and square it

853
01:01:16,627 --> 01:01:18,181
do you get something very close to X?

854
01:01:18,582 --> 01:01:22,232
For example one way to say that
is to say I square the guess,

855
01:01:22,835 --> 01:01:27,464
subtract X from that and see if
the absolute value of that whole thing

856
01:01:27,865 --> 01:01:29,658
is less than some small number,

857
01:01:30,449 --> 01:01:32,622
which depends on my purposes.

858
01:01:34,750 --> 01:01:36,282
OK. So, there's a...

859
01:01:37,545 --> 01:01:40,912
there's a complete procedure
for how to compute the square root of X.

860
01:01:41,362 --> 01:01:44,347
Let's look at
the structure of that a little bit.

861
01:01:48,402 --> 01:01:55,073
I have the whole thing. I have the
notion of how to compute a square root.

862
01:01:55,474 --> 01:01:58,249
That's some kind of module.
Right? That's some kind of black-box.

863
01:01:58,667 --> 01:02:01,964
It's defined in terms of...

864
01:02:03,816 --> 01:02:08,217
It's defined in terms of how to try
a guess for the square root of X.

865
01:02:09,223 --> 01:02:15,840
Try is defined in terms of, well,
telling whether something is good enough

866
01:02:16,241 --> 01:02:18,277
and telling how to improve something.

867
01:02:18,678 --> 01:02:24,139
So, good enough...
Try is defined in terms of good-enough?

868
01:02:25,397 --> 01:02:29,459
and improve.

869
01:02:30,745 --> 01:02:32,328
And (let's see what else I'm filling)...

870
01:02:32,726 --> 01:02:34,052
If you go down this tree

871
01:02:34,610 --> 01:02:38,568
good-enough? was defined
in terms of absolute value and square.

872
01:02:40,642 --> 01:02:44,556
And improve was defined
in terms of something called averaging

873
01:02:45,028 --> 01:02:46,637
and then some other primitive operators.

874
01:02:47,427 --> 01:02:50,867
Square root is defined in terms of try.
Try is defined in terms of good-enough?

875
01:02:52,072 --> 01:02:55,066
and improve, but also try itself.

876
01:02:55,467 --> 01:03:01,075
So try is also defined
in terms of how to try itself.

877
01:03:02,713 --> 01:03:04,457
Well, that may give you some problem.

878
01:03:04,975 --> 01:03:09,825
Your high school geometry teacher
probably told you that it's naughty

879
01:03:10,226 --> 01:03:13,324
trying define things in terms of
themselves, cause it doesn't make sense.

880
01:03:13,725 --> 01:03:15,442
But that's false.

881
01:03:16,503 --> 01:03:19,734
Sometimes it makes perfect sense
to define things in terms of themselves.

882
01:03:20,260 --> 01:03:22,615
And this is a case.

883
01:03:23,210 --> 01:03:25,756
And we can look at that,
we can write down what this means

884
01:03:26,222 --> 01:03:30,577
Let's say suppose I ask LISP
what the square root of 2 is.

885
01:03:32,572 --> 01:03:34,739
Well, what does
the square root of 2 mean?

886
01:03:35,651 --> 01:03:44,096
Well, that means I try 1
as a guess for the square root of 2.

887
01:03:46,731 --> 01:03:50,935
Now, I look, I say gees, is 1 a good
enough guess for the square root of 2?

888
01:03:51,655 --> 01:03:54,160
That depends on the test
that good-enough does.

889
01:03:54,562 --> 01:03:56,347
And in this case
the good-enough will say no,

890
01:03:56,701 --> 01:03:59,061
1 is not a good enough guess
for the square root of 2.

891
01:03:59,584 --> 01:04:01,366
So, that will reduce to saying

892
01:04:01,650 --> 01:04:04,910
I have to try

893
01:04:06,818 --> 01:04:12,990
the improved and improved... improve 1
as a guess for the square root of 2

894
01:04:14,882 --> 01:04:17,860
and try that as a guess
for the square root of 2.

895
01:04:18,931 --> 01:04:25,731
Improving 1 as a guess for the square
root of 2 means I average 1 and 2/1.

896
01:04:26,980 --> 01:04:28,884
So, this is gonna be the average...

897
01:04:29,464 --> 01:04:39,933
this piece here will be the average
of 1 and the quotient of 2 by 1.

898
01:04:40,883 --> 01:04:42,874
So, this piece here.

899
01:04:43,848 --> 01:04:47,457
And I'm gonna try... And this is 1.5...

900
01:04:49,010 --> 01:04:54,122
So, this square root of 2 reduces
to trying 1 for the square root of 2,

901
01:04:54,588 --> 01:05:02,200
which reduces to trying 1.5

902
01:05:03,115 --> 01:05:05,592
as a guess for the square root of 2.

903
01:05:06,032 --> 01:05:09,145
Right? So that makes sense.
Let's look at the rest of the process.

904
01:05:09,538 --> 01:05:14,430
Here, if I try 1.5, that reduces...

905
01:05:14,831 --> 01:05:19,065
1.5 turns out to be not good enough
as a guess for the square root of 2.

906
01:05:19,879 --> 01:05:23,797
So, that reduces to trying
the average of 1.5 and 2/1.5

907
01:05:24,198 --> 01:05:26,561
as a guess for the square root of 2.

908
01:05:28,127 --> 01:05:30,275
That average turns out to be 1.3333,

909
01:05:30,959 --> 01:05:33,748
So, this whole thing reduces
to trying 1.3333 as a guess

910
01:05:34,149 --> 01:05:36,224
for the square root of 2,and then so on.

911
01:05:37,298 --> 01:05:39,719
Right? That reduces
to another call to good-enough.

912
01:05:40,095 --> 01:05:45,812
1.4xxx and then it keeps going until the
process finally stops with something that

913
01:05:46,177 --> 01:05:51,371
that good-enough thinks is good enough
which in this case is 1.4142xxx.

914
01:05:52,366 --> 01:05:56,515
So, the process makes perfect sense.

915
01:05:59,353 --> 01:06:06,366
This by the way
is called a recursive definition

916
01:06:13,928 --> 01:06:18,623
And the ability to make
recursive definitions

917
01:06:19,251 --> 01:06:20,823
is a source of incredible power.

918
01:06:21,721 --> 01:06:23,653
I've hinted that it's the thing

919
01:06:24,249 --> 01:06:27,252
that effectively allows you to do
these infinite computations that go on

920
01:06:27,653 --> 01:06:29,296
until something is true.

921
01:06:29,621 --> 01:06:33,741
Without having any other constructs other
than the ability to call a procedure.

922
01:06:35,338 --> 01:06:38,979
Let's see there's one more thing
in this. Let me show you a variant

923
01:06:39,463 --> 01:06:41,317
of this definition of square root.

924
01:06:43,119 --> 01:06:47,889
Look here on this slide. Here is a...
Here's a sort of the same thing.

925
01:06:48,248 --> 01:06:50,195
What I've done here is packaged

926
01:06:50,609 --> 01:06:55,858
the definitions of improve and
good-enough and try inside square root.

927
01:06:56,639 --> 01:07:00,669
So in fact what I've done
is I've built the square root box.

928
01:07:01,746 --> 01:07:07,769
I've built a box that's this square root
procedure that someone can use.

929
01:07:08,170 --> 01:07:11,423
They might put in 36 and get out 6.

930
01:07:11,833 --> 01:07:13,696
And then packaged inside this box,

931
01:07:14,131 --> 01:07:24,247
right, the definitions of try,
and good-enough, and improve.

932
01:07:26,845 --> 01:07:30,583
So they're hidden inside this box
and the reason for doing that is that

933
01:07:31,104 --> 01:07:33,000
if someone is using this square root...

934
01:07:33,360 --> 01:07:36,464
if George is using this square root,
George probably doesn't care very much

935
01:07:36,905 --> 01:07:39,545
that when I implemented square root

936
01:07:40,058 --> 01:07:44,870
I had things inside there
called try and good-enough and improve.

937
01:07:46,018 --> 01:07:48,704
And in fact, Harry
might have a cube root procedure

938
01:07:49,105 --> 01:07:50,898
that has try and good-enough and improve

939
01:07:51,257 --> 01:07:53,672
And in order to not get the whole system
confused it will be good for Harry

940
01:07:54,073 --> 01:07:57,824
to package his internal procedures
inside his cube root procedure.

941
01:07:58,272 --> 01:08:03,133
This is called block structure.
This particular way of packaging

942
01:08:05,583 --> 01:08:09,047
internals inside of a definition.

943
01:08:09,692 --> 01:08:13,968
And let's go back and look at this
slide again. The way to read this

944
01:08:14,412 --> 01:08:18,641
this kind of procedure is
to say to define square root...

945
01:08:19,793 --> 01:08:21,553
well, inside that definition

946
01:08:22,015 --> 01:08:24,423
I'll have the definition of improve,

947
01:08:24,926 --> 01:08:29,259
and the definition of good-enough,
and the definition of try.

948
01:08:29,685 --> 01:08:35,393
And then subject to those definitions
the way I do square root is to try 1.

949
01:08:35,983 --> 01:08:39,189
And notice here I don't have to say
1 as a guess for the square root of X.

950
01:08:39,767 --> 01:08:44,462
Because since it's all inside this
square root it sort of has this X now.

951
01:08:54,223 --> 01:08:56,105
OK. Well, let me summarize.

952
01:08:56,506 --> 01:08:58,623
We started out with the idea

953
01:08:59,003 --> 01:09:03,562
that what we're gonna be doing
is expressing imperative knowledge.

954
01:09:04,965 --> 01:09:09,319
And in fact here's a slide that
summarizes the way we've looked at LISP.

955
01:09:09,700 --> 01:09:12,880
We started out
by looking at some primitive elements:

956
01:09:13,432 --> 01:09:15,323
addition, multiplication,

957
01:09:15,796 --> 01:09:19,266
some predicates for testing whether
something is less than or something is equal

958
01:09:19,567 --> 01:09:21,110
and in fact we saw really snickly

959
01:09:21,588 --> 01:09:24,517
in the system we're actually using
these aren't actually primitives

960
01:09:24,900 --> 01:09:26,208
but it doesn't matter.

961
01:09:26,509 --> 01:09:28,186
What matters is we're gonna
use them as if they are primitives,

962
01:09:28,587 --> 01:09:29,922
we're not gonna look inside.

963
01:09:30,223 --> 01:09:33,420
We also have
some primitive data... some numbers.

964
01:09:34,071 --> 01:09:39,128
We saw some means of composition, means
of combination, the basic one being

965
01:09:39,816 --> 01:09:44,379
composing functions and building
combinations with operators and operands.

966
01:09:44,796 --> 01:09:49,127
And there is some other things
like COND and IF and DEFINE.

967
01:09:51,099 --> 01:09:53,317
But the main thing
about define in particular

968
01:09:53,735 --> 01:09:57,151
was that it was the means of abstraction,
it was the way that we name things.

969
01:09:57,552 --> 01:09:59,603
You can also see from this slide
not only where we've been

970
01:10:00,004 --> 01:10:01,917
but holes we have to fill in.
At some point

971
01:10:02,339 --> 01:10:05,980
we'll have to talk about how you combine
primitive data to get compound data,

972
01:10:06,398 --> 01:10:08,059
and how you abstract data,

973
01:10:08,518 --> 01:10:13,371
so you can use large clumps
of data as if they were primitive.

974
01:10:13,905 --> 01:10:15,839
So, that's where we're going.

975
01:10:16,315 --> 01:10:22,403
But before we do that for the next couple
of lectures we're gonna be talking about

976
01:10:23,156 --> 01:10:28,148
first of all how it is that you make a
link between these procedures we write

977
01:10:28,633 --> 01:10:31,167
and the processes
that happen in the machine.

978
01:10:31,973 --> 01:10:33,629
And then how it is

979
01:10:34,030 --> 01:10:35,735
that you start using the power of LISP

980
01:10:36,291 --> 01:10:39,449
to talk not only about
these individual little computations

981
01:10:39,850 --> 01:10:44,449
but about general
conventional methods of doing things.

982
01:10:44,974 --> 01:10:46,475
OK. Are there any questions?

983
01:10:46,804 --> 01:10:50,411
-Yes.If we'd defined A using parentheses

984
01:10:50,810 --> 01:10:53,030
instead of as we did
what would be the difference?

985
01:10:53,391 --> 01:10:55,099
-If I wrote this...

986
01:10:55,752 --> 01:11:02,669
If I wrote that what I would be doing
is defining a procedure named A,

987
01:11:03,098 --> 01:11:04,997
in this case a procedure of no arguments,

988
01:11:06,302 --> 01:11:10,339
which when I ran it
would give me back 5 times 5.

989
01:11:10,696 --> 01:11:13,453
- I mean you come over the same thing
except for you really got a difference.

990
01:11:13,809 --> 01:11:14,734
- Right. And the difference...

991
01:11:15,147 --> 01:11:18,615
the difference would be in the old one,
let me be a little bit clearer here...

992
01:11:20,089 --> 01:11:23,748
Let's call this A like here.

993
01:11:24,112 --> 01:11:26,305
And then pretend here just for contrast

994
01:11:27,113 --> 01:11:29,528
I wrote define...

995
01:11:30,604 --> 01:11:37,818
D to be the product of 5 and 5.

996
01:11:39,695 --> 01:11:41,413
And the difference between those.

997
01:11:41,865 --> 01:11:44,427
Let's think about interactions
with the LISP interpreter.

998
01:11:45,561 --> 01:11:49,357
I would type in A
and LISP would return 25.

999
01:11:52,852 --> 01:11:59,527
I could type in D...
if I just type in D, LISP would return

1000
01:12:01,144 --> 01:12:06,569
compound procedure D.

1001
01:12:07,345 --> 01:12:09,027
'Cause that's what it is,
it's a procedure.

1002
01:12:09,524 --> 01:12:12,110
I could run D. I could say
what's the value of running D?

1003
01:12:12,511 --> 01:12:15,247
Here is a combination with no operands.

1004
01:12:16,464 --> 01:12:18,757
And I see there are no operands.
I didn't put any after D.

1005
01:12:19,360 --> 01:12:21,507
And it would say Oh, that's 25.

1006
01:12:23,100 --> 01:12:26,550
Or I could say... just for completeness

1007
01:12:26,951 --> 01:12:30,357
if I typed in what's
the value of running A I get an error.

1008
01:12:31,481 --> 01:12:35,117
The error would be
the same one as over there.

1009
01:12:35,520 --> 01:12:39,032
The error would say sorry, 25,

1010
01:12:39,460 --> 01:12:43,703
which is the value of A, is not an
operator that I can apply to something.

1011
01:12:45,041 --> 01:12:46,274
OK.

1012
01:12:47,213 --> 01:12:52,857
Subtitles created by Sergey Khenkin
http://www.sicptitles.org

